--- a/tools/xl/xl_utils.c
+++ b/tools/xl/xl_utils.c
@@ -264,14 +264,18 @@
 
     postfork();
 
-    ret = libxl_create_logfile(ctx, name, &fullname);
-    if (ret) {
-        LOG("failed to open logfile %s: %s",fullname,strerror(errno));
-        exit(-1);
-    }
+    logfile = libxl_create_external_logger(name);
+    if (logfile < 0) {
+        ret = libxl_create_logfile(ctx, name, &fullname);
+        if (ret) {
+            LOG("failed to open logfile %s: %s",fullname,strerror(errno));
+            exit(-1);
+        }
+    
 
-    CHK_SYSCALL(logfile = open(fullname, O_WRONLY|O_CREAT|O_APPEND, 0644));
-    free(fullname);
+        CHK_SYSCALL(logfile = open(fullname, O_WRONLY|O_CREAT|O_APPEND, 0644));
+        free(fullname);
+    }
     assert(logfile >= 3);
 
     CHK_SYSCALL(nullfd = open("/dev/null", O_RDONLY));
--- a/tools/libxl/libxl_dm.c
+++ b/tools/libxl/libxl_dm.c
@@ -49,6 +49,11 @@
     char *logfile;
     int rc, logfile_w;
 
+    logfile_w = libxl_create_external_logger(name);
+    if (logfile_w >= 0) {
+	return logfile_w;
+    }
+
     rc = libxl_create_logfile(CTX, name, &logfile);
     if (rc) return rc;
 
--- a/tools/libxl/libxl_utils.c
+++ b/tools/libxl/libxl_utils.c
@@ -16,6 +16,8 @@
 #include "libxl_osdeps.h" /* must come before any other headers */
 
 #include <ctype.h>
+#include <sys/socket.h>
+#include <sys/un.h>
 
 #include "libxl_internal.h"
 #include "_paths.h"
@@ -253,6 +255,66 @@
         return ERROR_FAIL;
     }
     return 0;
+}
+
+static int send_fd_to_logger(int shared_fd, char *name, char *logger) {
+    int fd;
+    struct sockaddr_un addr;
+    struct msghdr message;
+    struct iovec iov[1];
+    struct cmsghdr *control_message = NULL;
+    char ctrl_buf[CMSG_SPACE(sizeof(int))];
+
+    /* fill out all the required C paperwork */
+    memset(&addr, 0, sizeof(addr));
+    addr.sun_family = AF_UNIX;
+    strcpy(addr.sun_path, logger);
+
+    memset(&message, 0, sizeof(struct msghdr));
+    memset(ctrl_buf, 0, CMSG_SPACE(sizeof(int)));
+    iov[0].iov_base = name;
+    iov[0].iov_len = strlen(name);
+
+    message.msg_name = NULL;
+    message.msg_namelen = 0;
+    message.msg_iov = iov;
+    message.msg_iovlen = 1;
+    message.msg_controllen =  CMSG_SPACE(sizeof(int));
+    message.msg_control = ctrl_buf;
+
+    control_message = CMSG_FIRSTHDR(&message);
+    control_message->cmsg_level = SOL_SOCKET;
+    control_message->cmsg_type = SCM_RIGHTS;
+    control_message->cmsg_len = CMSG_LEN(sizeof(int));
+    *((int *) CMSG_DATA(control_message)) = shared_fd;
+
+    /* now, do the deed */
+    fd = socket(AF_UNIX, SOCK_DGRAM, 0);
+    if (fd < 0)
+	goto bail;
+
+    if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
+        goto bail;
+
+    if (sendmsg(fd, &message, 0) < 0)
+        goto bail;
+
+    return 1;
+
+bail:
+    return 0;
+}
+
+int libxl_create_external_logger(char *name) {
+    int fds[2];
+
+    pipe(fds);
+    if (send_fd_to_logger(fds[0], name, "/var/run/linuxkit-external-logging.sock")) {
+        return fds[1];
+    }
+    close(fds[0]);
+    close(fds[1]);
+    return -1;
 }
 
 int libxl_create_logfile(libxl_ctx *ctx, const char *name, char **full_name)
--- a/tools/libxl/libxl_utils.h
+++ b/tools/libxl/libxl_utils.h
@@ -37,6 +37,7 @@
 int libxl_get_stubdom_id(libxl_ctx *ctx, int guest_domid);
 int libxl_is_stubdom(libxl_ctx *ctx, uint32_t domid, uint32_t *target_domid);
 int libxl_create_logfile(libxl_ctx *ctx, const char *name, char **full_name);
+int libxl_create_external_logger(char *name);
 int libxl_string_to_backend(libxl_ctx *ctx, char *s, libxl_disk_backend *backend);
 
 int libxl_read_file_contents(libxl_ctx *ctx, const char *filename,
--- a/tools/console/daemon/io.c
+++ b/tools/console/daemon/io.c
@@ -39,6 +39,8 @@
 #include <time.h>
 #include <assert.h>
 #include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
 #if defined(__NetBSD__) || defined(__OpenBSD__)
 #include <util.h>
 #elif defined(__linux__)
@@ -416,10 +418,70 @@
 	return ret;
 }
 
+static int send_fd_to_logger(int shared_fd, char *name, char *logger) {
+    int fd;
+    struct sockaddr_un addr;
+    struct msghdr message;
+    struct iovec iov[1];
+    struct cmsghdr *control_message = NULL;
+    char ctrl_buf[CMSG_SPACE(sizeof(int))];
+
+    /* fill out all the required C paperwork */
+    memset(&addr, 0, sizeof(addr));
+    addr.sun_family = AF_UNIX;
+    strcpy(addr.sun_path, logger);
+
+    memset(&message, 0, sizeof(struct msghdr));
+    memset(ctrl_buf, 0, CMSG_SPACE(sizeof(int)));
+    iov[0].iov_base = name;
+    iov[0].iov_len = strlen(name);
+
+    message.msg_name = NULL;
+    message.msg_namelen = 0;
+    message.msg_iov = iov;
+    message.msg_iovlen = 1;
+    message.msg_controllen =  CMSG_SPACE(sizeof(int));
+    message.msg_control = ctrl_buf;
+
+    control_message = CMSG_FIRSTHDR(&message);
+    control_message->cmsg_level = SOL_SOCKET;
+    control_message->cmsg_type = SCM_RIGHTS;
+    control_message->cmsg_len = CMSG_LEN(sizeof(int));
+    *((int *) CMSG_DATA(control_message)) = shared_fd;
+
+    /* now, do the deed */
+    fd = socket(AF_UNIX, SOCK_DGRAM, 0);
+    if (fd < 0)
+	goto bail;
+
+    if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
+        goto bail;
+
+    if (sendmsg(fd, &message, 0) < 0)
+        goto bail;
+
+    return 1;
+
+bail:
+    return 0;
+}
+
 static int create_hv_log(void)
 {
 	char logfile[PATH_MAX];
 	int fd;
+	int fds[2];
+
+	pipe(fds);
+	if (send_fd_to_logger(fds[0], "hypervisor", "/var/run/linuxkit-external-logging.sock")) {
+		return fds[1];
+	} else {
+		dolog(LOG_ERR, "Failed to establish connection with the logger %d (%s)",
+				errno, strerror(errno));
+		close(fds[0]);
+		close(fds[1]);
+	}
+
 	snprintf(logfile, PATH_MAX-1, "%s/hypervisor.log", log_dir);
 	logfile[PATH_MAX-1] = '\0';
 
@@ -444,8 +506,10 @@
 static int create_console_log(struct console *con)
 {
 	char logfile[PATH_MAX];
+	char logname[PATH_MAX];
 	char *namepath, *data, *s;
 	int fd;
+	int fds[2];
 	unsigned int len;
 	struct domain *dom = con->d;
 
@@ -468,9 +532,22 @@
 
 	snprintf(logfile, PATH_MAX-1, "%s/guest-%s%s.log",
 		 log_dir, data, con->log_suffix);
+	snprintf(logname, PATH_MAX-1, "guest_vm/%s%s",
+		 data, con->log_suffix);
 
 	free(data);
 	logfile[PATH_MAX-1] = '\0';
+	logname[PATH_MAX-1] = '\0';
+
+        pipe(fds);
+        if (send_fd_to_logger(fds[0], logname, "/var/run/linuxkit-external-logging.sock")) {
+                return fds[1];
+        } else {
+                dolog(LOG_ERR, "Failed to establish connection with the logger %d (%s)",
+                                errno, strerror(errno));
+                close(fds[0]);
+                close(fds[1]);
+        }
 
 	fd = open(logfile, O_WRONLY|O_CREAT|O_APPEND, 0644);
 	if (fd == -1)
