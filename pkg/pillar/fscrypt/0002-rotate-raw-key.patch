From e0dff1a585698f43ad6dfda29caf21207fd35fbe Mon Sep 17 00:00:00 2001
From: Petr Fedchenkov <giggsoff@gmail.com>
Date: Tue, 20 Sep 2022 13:20:17 +0300
Subject: [PATCH 2/2] rotate raw key

Signed-off-by: Petr Fedchenkov <giggsoff@gmail.com>
---
 cmd/fscrypt/commands.go |  2 +-
 cmd/fscrypt/flags.go    | 10 +++++++++-
 cmd/fscrypt/keys.go     | 10 +++-------
 cmd/fscrypt/prompt.go   | 12 +++++++++---
 4 files changed, 22 insertions(+), 12 deletions(-)

diff --git a/cmd/fscrypt/commands.go b/cmd/fscrypt/commands.go
index 30aa3a7..86836d8 100644
--- a/cmd/fscrypt/commands.go
+++ b/cmd/fscrypt/commands.go
@@ -973,7 +973,7 @@ var changePassphrase = cli.Command{
 	Description: `This command takes a specified passphrase protector and
 		changes the corresponding passphrase. Note that this does not
 		create or destroy any protectors.`,
-	Flags:  []cli.Flag{protectorFlag},
+	Flags:  []cli.Flag{protectorFlag, sourceFlag, keyFileFlag, oldKeyFileFlag},
 	Action: changePassphraseAction,
 }
 
diff --git a/cmd/fscrypt/flags.go b/cmd/fscrypt/flags.go
index 1b41839..de3c293 100644
--- a/cmd/fscrypt/flags.go
+++ b/cmd/fscrypt/flags.go
@@ -115,7 +115,7 @@ var (
 	// TODO(joerichey) add presubmit rule to enforce this
 	allFlags = []prettyFlag{helpFlag, versionFlag, verboseFlag, quietFlag,
 		forceFlag, skipUnlockFlag, timeTargetFlag,
-		sourceFlag, nameFlag, keyFileFlag, protectorFlag,
+		sourceFlag, nameFlag, keyFileFlag, oldKeyFileFlag, protectorFlag,
 		unlockWithFlag, policyFlag, allUsersLockFlag, allUsersSetupFlag,
 		noRecoveryFlag}
 	// universalFlags contains flags that should be on every command
@@ -224,6 +224,14 @@ var (
 			formatted as raw binary and should be exactly 32 bytes
 			long.`,
 	}
+	oldKeyFileFlag = &stringFlag{
+		Name:    "old-key",
+		ArgName: "FILE",
+		Usage: `Use the contents of FILE as the wrapping key when
+			creating or unlocking raw_key protectors. FILE should be
+			formatted as raw binary and should be exactly 32 bytes
+			long.`,
+	}
 	userFlag = &stringFlag{
 		Name:    "user",
 		ArgName: "USERNAME",
diff --git a/cmd/fscrypt/keys.go b/cmd/fscrypt/keys.go
index 28171a4..b10c70e 100644
--- a/cmd/fscrypt/keys.go
+++ b/cmd/fscrypt/keys.go
@@ -106,7 +106,7 @@ func getPassphraseKey(prompt string) (*crypto.Key, error) {
 	return crypto.NewKeyFromReader(passphraseReader{})
 }
 
-func makeRawKey(info actions.ProtectorInfo) (*crypto.Key, error) {
+func makeRawKey(info actions.ProtectorInfo, old bool) (*crypto.Key, error) {
 	// When running non-interactively and no key was provided,
 	// try to read it from stdin
 	if keyFileFlag.Value == "" && !term.IsTerminal(stdinFd) {
@@ -116,7 +116,7 @@ func makeRawKey(info actions.ProtectorInfo) (*crypto.Key, error) {
 
 	prompt := fmt.Sprintf("Enter key file for protector %q: ", info.Name())
 	// Raw keys use a file containing the key data.
-	file, err := promptForKeyFile(prompt)
+	file, err := promptForKeyFile(prompt, old)
 	if err != nil {
 		return nil, err
 	}
@@ -181,11 +181,7 @@ func makeKeyFunc(supportRetry, shouldConfirm bool, prefix string) actions.KeyFun
 			return key, nil
 
 		case metadata.SourceType_raw_key:
-			// Only use prefixes with passphrase protectors.
-			if prefix != "" {
-				return nil, ErrNotPassphrase
-			}
-			return makeRawKey(info)
+			return makeRawKey(info, prefix == "old ")
 
 		default:
 			return nil, ErrInvalidSource
diff --git a/cmd/fscrypt/prompt.go b/cmd/fscrypt/prompt.go
index d34a18a..85fbaad 100644
--- a/cmd/fscrypt/prompt.go
+++ b/cmd/fscrypt/prompt.go
@@ -216,10 +216,16 @@ func promptForSource(ctx *actions.Context) error {
 
 // promptForKeyFile returns an open file that should be used to create or unlock
 // a raw_key protector. Be sure to close the file when done.
-func promptForKeyFile(prompt string) (*os.File, error) {
+func promptForKeyFile(prompt string, old bool) (*os.File, error) {
 	// If specified on the command line, we only try no open it once.
-	if keyFileFlag.Value != "" {
-		return os.Open(keyFileFlag.Value)
+	if old {
+		if oldKeyFileFlag.Value != "" {
+			return os.Open(oldKeyFileFlag.Value)
+		}
+	} else {
+		if keyFileFlag.Value != "" {
+			return os.Open(keyFileFlag.Value)
+		}
 	}
 	if quietFlag.Value {
 		return nil, ErrSpecifyKeyFile
-- 
2.34.1

