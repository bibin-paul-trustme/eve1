// Copyright (c) 2018 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

package agentlog

import (
	"fmt"
	"io/ioutil"
	"log/syslog"
	"os"
	"os/signal"
	"runtime"
	dbg "runtime/debug"
	"syscall"
	"time"

	"github.com/lf-edge/eve/pkg/pillar/types"
	"github.com/lf-edge/eve/pkg/pillar/zboot"
	log "github.com/sirupsen/logrus"
	lSyslog "github.com/sirupsen/logrus/hooks/syslog"
)

const (
	reasonFile = "reboot-reason"
	stackFile  = "reboot-stack"
)

var savedAgentName string = "unknown" //Â Keep for signal and exit handlers

// Parameter description
// 1. agentName: Name with which disk log file will be created.
// 2. logdir: Directory in which disk log file will be placed.
// 3. redirect: Set the selected log destination (file/syslog) as default
//              for the logs generated by current process.
//              examples: When we created a child process that takes care of it's
//                        own logging.
// 4. text: Test based loggin i.e. logs do into a file created based on
//          the argument values passed for agentName & logdir.
//          examples: logmanager
func initImpl(agentName string, logdir string, redirect bool,
	text bool) (*os.File, error) {

	var err error
	var logf *os.File
	var logToSyslog = false
	if os.Getenv("LOG_TO_SYSLOG") != "" {
		logToSyslog = true
	}

	if text {
		logfile := fmt.Sprintf("%s/%s.log", logdir, agentName)
		logf, err = os.OpenFile(logfile, os.O_RDWR|os.O_CREATE|os.O_APPEND,
			0666)
		if err != nil {
			return nil, err
		}
	}
	if redirect {
		if text {
			log.SetOutput(logf)
		} else if logToSyslog {
			log.SetOutput(ioutil.Discard)
			syslogFlags := syslog.LOG_INFO | syslog.LOG_DEBUG | syslog.LOG_ERR |
				syslog.LOG_NOTICE | syslog.LOG_WARNING | syslog.LOG_CRIT |
				syslog.LOG_ALERT | syslog.LOG_EMERG
			hook, err := lSyslog.NewSyslogHook("", "", syslogFlags, agentName)
			if err == nil {
				log.AddHook(hook)
			} else {
				return nil, err
			}
		} else {
			log.SetOutput(os.Stdout)
		}
		if text {
			// Report nano timestamps
			formatter := log.TextFormatter{
				TimestampFormat: time.RFC3339Nano,
			}
			log.SetFormatter(&formatter)
		} else {
			// Report nano timestamps
			formatter := log.JSONFormatter{
				TimestampFormat: time.RFC3339Nano,
			}
			log.SetFormatter(&formatter)
		}
		log.SetReportCaller(true)
		log.RegisterExitHandler(printStack)

		sigs := make(chan os.Signal, 1)
		signal.Notify(sigs, syscall.SIGUSR1)
		signal.Notify(sigs, syscall.SIGUSR2)
		go handleSignals(sigs)
	}
	return logf, nil
}

// Wait on channel then handle the signals
func handleSignals(sigs chan os.Signal) {
	for {
		select {
		case sig := <-sigs:
			log.Infof("handleSignals: received %v\n", sig)
			switch sig {
			case syscall.SIGUSR1:
				log.Warnf("SIGUSR1 triggered stack traces:\n%v\n",
					getStacks(true))
			case syscall.SIGUSR2:
				log.Warnf("SIGUSR2 triggered memory info:\n")
				logMemUsage()
				logGCStats()
			}
		}
	}
}

// Print out our stack
func printStack() {
	stacks := getStacks(false)
	log.Errorf("fatal stack trace:\n%v\n", stacks)
	RebootReason(fmt.Sprintf("fatal: agent %s exit", savedAgentName))
	RebootStack(stacks)
}

// RebootReason writes a reason string in /persist/IMGx/reboot-reason, including agentName and date
func RebootReason(reason string) {
	filename := fmt.Sprintf("%s/%s", getCurrentIMGdir(), reasonFile)
	log.Warnf("RebootReason to %s: %s\n", filename, reason)
	dateStr := time.Now().Format(time.RFC3339Nano)
	err := printToFile(filename, fmt.Sprintf("Reboot from agent %s at %s: %s\n",
		savedAgentName, dateStr, reason))
	if err != nil {
		log.Errorf("printToFile failed %s\n", err)
	}
	syscall.Sync()
}

// RebootStack writes stack in /persist/IMGx/reboot-stack
func RebootStack(stacks string) {
	filename := fmt.Sprintf("%s/%s", getCurrentIMGdir(), stackFile)
	log.Warnf("RebootStack to %s", filename)
	err := printToFile(filename, fmt.Sprintf("%v\n", stacks))
	if err != nil {
		log.Errorf("printToFile failed %s\n", err)
	}
	syscall.Sync()
}

func GetCurrentRebootReason() (string, time.Time, string) {
	reasonFilename := fmt.Sprintf("%s/%s", getCurrentIMGdir(), reasonFile)
	stackFilename := fmt.Sprintf("%s/%s", getCurrentIMGdir(), stackFile)
	reason, ts := statAndRead(reasonFilename)
	stack, _ := statAndRead(stackFilename)
	return reason, ts, stack
}

func GetOtherRebootReason() (string, time.Time, string) {
	dirname := getOtherIMGdir(false)
	if dirname == "" {
		return "", time.Time{}, ""
	}
	reasonFilename := fmt.Sprintf("%s/%s", dirname, reasonFile)
	stackFilename := fmt.Sprintf("%s/%s", dirname, stackFile)
	reason, ts := statAndRead(reasonFilename)
	stack, _ := statAndRead(stackFilename)
	return reason, ts, stack
}

// Used for failures/hangs when zboot curpart hangs
func GetCommonRebootReason() (string, time.Time, string) {
	reasonFilename := fmt.Sprintf("%s/%s", types.PersistDir, reasonFile)
	stackFilename := fmt.Sprintf("%s/%s", types.PersistDir, stackFile)
	reason, ts := statAndRead(reasonFilename)
	stack, _ := statAndRead(stackFilename)
	return reason, ts, stack
}

// Returns content and Modtime
func statAndRead(filename string) (string, time.Time) {
	fi, err := os.Stat(filename)
	if err != nil {
		// File doesn't exist
		return "", time.Time{}
	}
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		log.Errorf("statAndRead failed %s", err)
		return "", fi.ModTime()
	}
	return string(content), fi.ModTime()
}

// Append if file exists.
func printToFile(filename string, str string) error {
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY|os.O_CREATE,
		os.ModeAppend)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = f.WriteString(str)
	if err != nil {
		return err
	}
	return nil
}

func DiscardCurrentRebootReason() {
	reasonFilename := fmt.Sprintf("%s/%s", getCurrentIMGdir(), reasonFile)
	stackFilename := fmt.Sprintf("%s/%s", getCurrentIMGdir(), stackFile)
	if err := os.Remove(reasonFilename); err != nil {
		log.Errorf("DiscardCurrentRebootReason failed %s\n", err)
	}
	if err := os.Remove(stackFilename); err != nil {
		log.Errorf("DiscardCurrentRebootReason failed %s\n", err)
	}
}

func DiscardOtherRebootReason() {
	dirname := getOtherIMGdir(false)
	if dirname == "" {
		return
	}
	reasonFilename := fmt.Sprintf("%s/%s", dirname, reasonFile)
	stackFilename := fmt.Sprintf("%s/%s", dirname, stackFile)
	if err := os.Remove(reasonFilename); err != nil {
		log.Errorf("DiscardOtherRebootReason failed %s\n", err)
	}
	if err := os.Remove(stackFilename); err != nil {
		log.Errorf("DiscardOtherRebootReason failed %s\n", err)
	}
}

func DiscardCommonRebootReason() {
	reasonFilename := fmt.Sprintf("%s/%s", types.PersistDir, reasonFile)
	stackFilename := fmt.Sprintf("%s/%s", types.PersistDir, stackFile)
	if err := os.Remove(reasonFilename); err != nil {
		log.Errorf("DiscardCommonRebootReason failed %s\n", err)
	}
	if err := os.Remove(stackFilename); err != nil {
		log.Errorf("DiscardCommonRebootReason failed %s\n", err)
	}
}

func getStacks(all bool) string {
	var (
		buf       []byte
		stackSize int
	)
	bufferLen := 16384
	for stackSize == len(buf) {
		buf = make([]byte, bufferLen)
		stackSize = runtime.Stack(buf, all)
		bufferLen *= 2
	}
	buf = buf[:stackSize]
	return string(buf)
}

func logGCStats() {
	var m dbg.GCStats

	dbg.ReadGCStats(&m)
	log.Infof("GCStats %+v\n", m)
}

func logMemUsage() {
	var m runtime.MemStats

	runtime.ReadMemStats(&m)

	log.Infof("Alloc %v Mb", roundToMb(m.Alloc))
	log.Infof("TotalAlloc %v Mb", roundToMb(m.TotalAlloc))
	log.Infof("Sys %v Mb", roundToMb(m.Sys))
	log.Infof("NumGC %v", m.NumGC)
	log.Infof("MemStats %+v", m)
}

func roundToMb(b uint64) uint64 {

	kb := (b + 512) / 1024
	mb := (kb + 512) / 1024
	return mb
}

func Init(agentName string, curpart string) (*os.File, error) {
	if curpart != "" {
		zboot.SetCurpart(curpart)
	}
	logdir := GetCurrentLogdir()
	savedAgentName = agentName
	return initImpl(agentName, logdir, true, false)
}

func InitWithDirText(agentName string, logdir string, curpart string) (*os.File, error) {
	if curpart != "" {
		zboot.SetCurpart(curpart)
	}
	savedAgentName = agentName
	return initImpl(agentName, logdir, true, true)
}

// Setup and return a logf, but don't redirect our log.*
func InitChild(agentName string) (*os.File, error) {
	logdir := GetCurrentLogdir()
	return initImpl(agentName, logdir, false, false)
}

var currentIMGdir = ""

func getCurrentIMGdir() string {

	if currentIMGdir != "" {
		return currentIMGdir
	}
	partName := zboot.GetCurrentPartition()
	currentIMGdir = fmt.Sprintf("%s/%s", types.PersistDir, partName)
	return currentIMGdir
}

var otherIMGdir = ""

func getOtherIMGdir(inprogressCheck bool) string {

	if otherIMGdir != "" {
		return otherIMGdir
	}
	if inprogressCheck && !zboot.IsOtherPartitionStateInProgress() {
		return ""
	}
	partName := zboot.GetOtherPartition()
	otherIMGdir = fmt.Sprintf("%s/%s", types.PersistDir, partName)
	return otherIMGdir
}

// Return a logdir for agents and logmanager to use by default
func GetCurrentLogdir() string {
	return fmt.Sprintf("%s/log", getCurrentIMGdir())
}

// If the other partition is not inprogress we return the empty string
func GetOtherLogdir() string {
	dirname := getOtherIMGdir(true)
	if dirname == "" {
		return ""
	}
	return fmt.Sprintf("%s/log", dirname)
}

// Debug info to tell how often/late we call stillRunning; keyed by agentName
var lastStillMap = make(map[string]time.Time)

// Touch a file per agentName to signal the event loop is still running
// Could be use by watchdog
func StillRunning(agentName string, warnTime time.Duration, errTime time.Duration) {
	log.Debugf("StillRunning(%s)\n", agentName)

	if ls, found := lastStillMap[agentName]; !found {
		lastStillMap[agentName] = time.Now()
	} else {
		elapsed := time.Since(ls)
		if elapsed > errTime {
			log.Errorf("StillRunning(%s) XXX took a long time: %d",
				agentName, elapsed/time.Second)
		} else if elapsed > warnTime {
			log.Warnf("StillRunning(%s) took a long time: %d",
				agentName, elapsed/time.Second)
		}
		lastStillMap[agentName] = time.Now()
	}

	filename := fmt.Sprintf("/var/run/%s.touch", agentName)
	_, err := os.Stat(filename)
	if err != nil {
		file, err := os.Create(filename)
		if err != nil {
			log.Infof("StillRunning: %s\n", err)
			return
		}
		file.Close()
	}
	_, err = os.Stat(filename)
	if err != nil {
		log.Errorf("StilRunning: %s\n", err)
		return
	}
	now := time.Now()
	err = os.Chtimes(filename, now, now)
	if err != nil {
		log.Errorf("StillRunning: %s\n", err)
		return
	}
}
