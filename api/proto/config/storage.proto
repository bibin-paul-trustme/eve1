// Copyright(c) 2017-2020 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package org.lfedge.eve.config;
option go_package = "github.com/lf-edge/eve/api/go/config";
option java_package = "org.lfedge.eve.config";

import "config/devcommon.proto";
import "config/acipherinfo.proto";
import "evecommon/evecommon.proto";

// XXX this will be deprecated when all deployed instances of EVE
// no longer expect it. 5.6.X depend on it. 5.7.1 does not.
message SignatureInfo {
  string intercertsurl = 1;
  string signercerturl = 2;
  bytes signature = 3;
}

enum DsType {
  DsUnknown = 0;
  DsHttp    = 1;
  DsHttps   = 2;
  DsS3      = 3;
  DsSFTP    = 4;
  DsContainerRegistry = 5;
  DsAzureBlob = 6;
  DsGoogleStorage = 7;
}

// The DataStoreConfig contains common parameters for a give source of
// images aka ContentTrees, such as the credentials and server
message DatastoreConfig {
  string id = 100; // UUID

  DsType dType = 1;

  string fqdn = 2; // Fully-qualified domain name of server

  // to be deprecated, use cipherData instead
  string apiKey = 3;

  // to be deprecated, use cipherData instead
  string password = 4;

  // depending on datastore types, it could be bucket or path
  string dpath = 5;

  // Applies for some datastore types
  string region = 6;

  // contains the encrypted credentials
  CipherBlock cipherData = 7;

  // Uploaded datastore certificate or certificate chain
  repeated bytes dsCertPEM = 8;
}


enum Format {
  FmtUnknown = 0;
  RAW   = 1;
  QCOW  = 2;
  QCOW2 = 3;
  VHD   = 4;
  VMDK  = 5;
  OVA   = 6;
  VHDX  = 7;
  CONTAINER = 8;
}

// XXX the Image will be deprecated and we will use ContentTree instead
message Image {
  UUIDandVersion uuidandversion = 1;
  // it could be relative path/name as well; appended to the datastore dpath
  string name = 2;

  string sha256 = 3; // EVE will verify this sha for the content
  Format iformat = 4;

  // if its signed image
  SignatureInfo siginfo = 5;

  string dsId = 6; // Datastore UUID
  // sizeBytes indicates the maximum download size of an image.
  // A value of 0 will indicate the unlimited download.
  int64 sizeBytes = 8;
}

enum Target {
  TgtUnknown = 0;
  Disk   = 1;
  Kernel = 2;
  Initrd = 3;
  RamDisk = 4;
  // XXX DeviceTree?
}

// XXX the DriveType will be deprecated when we deprecate Drive
enum DriveType {
  Unclassified = 0;
  CDROM   = 1;
  HDD     = 2;
  NET     = 3;

  // this type is allocate the empty disk of maxsizebytes specified
  HDD_EMPTY  = 4;
}

// XXX the Drive will be deprecated and we will use Volumes instead
message Drive {
  Image image = 1;
  bool readonly = 5;
  bool preserve = 6; // XXX deprecate; EVE always preserves unless there is a purge
  DriveType drvtype = 8;
  Target target = 9;
  // maxsizebytes indicates the maximum size of the volume.
  // Initial image size will be resized to the maxsizebytes
  // iff maxsizebytes is greater than the image size.
  int64 maxsizebytes = 10;
}

// ContentTree describes the top of some content tree. The controller needs
// to allocate a uuid for it, and that uuid will be sent by EVE in the
// ZInfoContentTree message
message ContentTree {
  string uuid = 1;
  string dsId  = 2; // UUID for DatastoreConfig
  string URL = 3;   // URL to append to datastore dpath
  Format iformat = 4;

  // The sha is for the top blob of the ContentTree
  string sha256 = 5;

  // maxSizeBytes used for capping resource consumption in EVE.
  // maxSizeBytes indicates the maximum download size of content tree.
  uint64 maxSizeBytes = 6;
  SignatureInfo siginfo = 7;
  string displayName = 8; // Optional friendly name echo'ed in info

  // For container ContentTree, sha256 might not be available in config.
  // If the sha256 is not available then it needs to be resolved corresponding to the tag
  // change in generation_count indicates that the resolution of tag is needed
  // generation_count needs to be updated when purge is required for an existing
  // instance. In case of new instance using the same content tree, EVE will get
  // new content tree UUID in the device configuration from the controller.
  int64 generation_count = 9;
}

// The protocol that the task will use to access the Volume
enum VolumeAccessProtocols {
  VAP_NONE = 0;
  VAP_9P = 1;
}

enum VolumeContentOriginType {
  VCOT_UNKNOWN = 0;
  VCOT_BLANK = 1;     // Create an empty directory/disk with specified size
  VCOT_DOWNLOAD = 2;  // Create from downloadContentTreeID
}

message VolumeContentOrigin {
  VolumeContentOriginType type = 1;
  string downloadContentTreeID = 2; // UUID for ContentTree
}

// The Volume describes a storage volume which should exist on the device.
// This can currently either be blank or created from a ContentTree
// If maxSizeBytes is zero it means unlimited by the controller. In that
// case EVE needs to determine how much space it can assign and limit any
// downloaded ContentTree and the created volume based on that calculated size.
message Volume {
  string uuid = 1;

  // origin of the volume content.
  VolumeContentOrigin origin = 2;

  // describes all the different ways how this Volume can
  // be offered to Tasks
  repeated VolumeAccessProtocols protocols = 3;

  // change in generationCount indicates that the mutated volume needs to be
  // purged and built from scratch. This is a generalization of the purge
  // command for an application instance
  int64 generationCount = 4;

  // miscellaneous attributes of the Volume
  // maxSizeBytes Used for capping resource consumption in EVE.
  // maxSizeBytes indicates the maximum size of the volume.
  int64 maxsizebytes = 5;
  bool readonly = 6;       // Will be offered to tasks as read-only
  string displayName = 7;  // Optional friendly name echo'ed in info message
  bool clear_text = 8;  // Flag to indicate the volume encryption needed or not
}

// DiskConfigType is the desired configuration of disks
enum DiskConfigType {
  DISK_CONFIG_TYPE_UNSPECIFIED = 0; // no configured, do nothing
  DISK_CONFIG_TYPE_EVEOS = 1; // the disk EVE is installed on
  DISK_CONFIG_TYPE_PERSIST = 2; // the disk is separate persist partition, not zfs
  DISK_CONFIG_TYPE_ZFS_ONLINE = 3; // included in zfs and online
  DISK_CONFIG_TYPE_ZFS_OFFLINE = 4; // included in zfs and offline
  DISK_CONFIG_TYPE_APPDIRECT = 5; // for direct assignment
  DISK_CONFIG_TYPE_UNUSED = 6; // removed from zfs/app-direct
}

//DiskConfig describe desired configuration of disk
//If we want change state to online/offline we should define its state
//If we want to add disk we should define it here and set DiskConfigType to online or offline
//If we want to remove disk we should set its state to unused or appdirect
//If we want to replace disk we should fill old_disk to be replaced with disk
//Progress of operation is expected to be available in info messages
message DiskConfig {
  org.lfedge.eve.common.DiskDescription disk = 1;
  // define old disk here to replace it with new one defined in disk, omit it to not use replacement
  org.lfedge.eve.common.DiskDescription old_disk = 2;
  DiskConfigType disk_config = 3;
}

// DisksArrayType is the desired configuration of disks in DisksConfig
enum DisksArrayType {
  DISKS_ARRAY_TYPE_UNSPECIFIED = 0; // no configured
  DISKS_ARRAY_TYPE_RAID0 = 1; // stripe
  DISKS_ARRAY_TYPE_RAID1 = 2; // mirror
  DISKS_ARRAY_TYPE_RAID5 = 3; // raidz1
  DISKS_ARRAY_TYPE_RAID6 = 4; // raidz2
}

//DisksConfig is a configuration of disks
//We expect information about disks to be filled and will try to adjust disks states accordingly
//All disks defined in disks field expected to have array type defined in array_type
//To support nested topologies we can use children field
//
//For example to use stripe of two pairs of mirrored disks we should define
//DisksConfig without disks with array_type DISKS_ARRAY_TYPE_RAID0
//with two children with properly defined disks inside and with array_type DISKS_ARRAY_TYPE_RAID1
//and empty children
message DisksConfig {
  repeated DiskConfig disks = 1;
  DisksArrayType array_type = 2;
  repeated DisksConfig children = 3;
}

// RollbackCmd - snapshot rollback command
//
// If the counter in the DeviceOpsCmd is different, it will cause a
// rollback operation.
//
// The fields from RollbackCmd (snapshot_uuid, volume_uuid) will
// always match the fields from the SnapshotConfig (snapshot_uuid, volume_uuid)
// to which RollbackCmd belongs.
//
// For example: take the situation where the controller requests one or more
// snapshots (uuid=1 for volume_uuid=X, then add a second SnapshotCmd
// with uuid=2 for volume_uuid=X), and then later it send a RollbackCmd with
// snapshot_uuid=1
//
// In this case, the following will happen:
// It is assumed that the RollbackCmd message cannot come separately from
// the configuration, and will always be part of the SnapshotConfig for
// every snapshot. And we will always receive from the controller a complete
// list of SnapshotConfig for all snapshots that the controller knows about.
// Then after the snapshot with uuid=2 has been created, we can also get
// a SnapshotConfig for uuid=1, where the counter in RollbackCmd will be +1.
// Thus, we will roll back to the state of the logical volume at the time
// of the snapshot with uuid=1, and the snapshot with uuid=2 will be marked
// in the info message how IMPLICITLY_DELETED (If the controller did not take
// care of deleting the snapshot with uuid=2 before the rollback command).
message RollbackCmd {
  // UUID of the snapshot to rollback to. Is the snapshot_uuid
  // from the SnapshotConfig and the real and unique name of the
  // snapshot in ZFS. This is the rollback target for volume_uuid.
  string snapshot_uuid = 1;
  string volume_uuid = 2;    // UUID of the volume to rollback
  DeviceOpsCmd rollback = 3; // Counter for rollback
}

// SnapshotConfig describes a snapshot for a specific logical
// volume that must exist on the device. It has a required field
// volume_uuid for which it was created and UUID for snapshot name in ZFS.
message SnapshotConfig {
  // The real name of the snapshot in ZFS. It is the link between
  // the command and the response to the command. It is assumed
  // that the field will always be filled with a unique value
  // that the controller will generate.
  string snapshot_uuid = 1;
  // Display name (User-friendly name). This name does not affect
  // the snapshot properties in ZFS in any way.
  // Can be filled on the controller side.
  // If a snapshot has already been created and this field has changed,
  // it can be assumed that the friendly name for this snapshot has
  // been renamed on the controller side.
  string display_name = 2;
  // Volume ID of the volume this snapshot belongs to. The field is
  // required for all messages. Must always be filled in on the
  // controller side before sending to create snapshot command.
  string volume_uuid = 3;
  // An "optional" snapshot rollback operation command, because
  // not all SnapshotConfig require a rollback command
  // If the RollbackCmd message is not enabled, it means that
  // a rollback is not requested. If RollbackCmd is enabled in this
  // config, then a rollback has been requested, and also the counter
  // in RollbackCmd will be checked.
  // It should also be taken that the rollback cmd
  // to snapshot k will implicitly automatically delete
  // all snapshots from k+1 to N, If the deletion of snapshots
  // from k+1 to N was not initiated by the controller before
  // the rollback cmd.
  RollbackCmd rollback = 4;
}
